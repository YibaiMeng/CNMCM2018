% !Mode:: "TeX:UTF-8"
%!TEX program  = xelatex

\documentclass{cumcmthesis}
%\documentclass[withoutpreface,bwprint]{cumcmthesis} %去掉封面与编号页

\usepackage{url}
\title{（2018B）智能RGV的动态调度策略}
\tihao{B}
\baominghao{01001015}
\schoolname{北京大学}
\membera{包慧语}
\memberb{孟逸白}
\memberc{吴越}
\supervisor{}
\yearinput{2018}
\monthinput{09}
\dayinput{16}

\begin{document}

\maketitle
\begin{abstract}

本文是对智能 RGV的动态调度策略问题的研究。我们对原问题建模并设计算法，然后在写好的模拟器代码上实现算法来求得在该算法下此智能RGV可以完成多少产品的加工任务。

第一种情况中，我们首先通过尝试了一种贪心的算法来求得答案，随后又使用了三层的深度优先搜索来决策，对这两种结果进行比较，评估一下算法的优劣。

第二种情况中，我们采用了类似的贪心策略，通过穷举加工第一道工序的CNC和加工第二道工序的CNC的排布方法，来选取可以加工最多的产品的排布，并利用设计的算法来模拟产品的加工，求得最后的答案。

第三种情况中，问题带有随机性。在前两问里，机器的行为是可以预测的，我们知道送给CNC的产品什么时候可以加工好，于是我们可以根据这一信息来进行决策，来决定RGV下一步的行动。而第三问则有一个随机的过程，机器在加工的过程中会有$1\%$的概率出现故障。对于只有一种工序的情况，我们运行20次取最后的平均值，来求得最后的答案，检验我们的算法有效性。对于两道工序的情况，我们同样穷举加工第一道工序的CNC和加工第二道工序的CNC的排布方法，然后运行20次取平均值，来选取平均意义下最优的排布方式，来解决这个问题。

\keywords{调度算法\quad  随机过程\quad   贪心策略\quad  穷举搜索\quad {\color{red}{还有啥}}}
\end{abstract}

%目录
\tableofcontents

\section{问题重述}

一个智能加工系统由8台计算机数控机床（Computer Number Controller，CNC）、1辆轨道式自动引导车（Rail Guide Vehicle，RGV）、1条RGV直线轨道、1条上料传送带、1条下料传送带等附属设备组成。RGV是一种无人驾驶、能在固定轨道上自由运行的智能车。它根据指令能自动控制移动方向和距离，并自带一个机械手臂、两只机械手爪和物料清洗槽，能够完成上下料及清洗物料等作业任务。

对各部件的详细解释：
（1）CNC：在上料传送带和下料传送带的两侧各安装4台CNC，等距排列，每台CNC同一时间只能安装1种刀具加工1个物料。
如果物料的加工过程需要两道工序，则需要有不同的CNC安装不同的刀具分别加工完成，在加工过程中不能更换刀具。第一和第二道工序需要在不同的CNC上依次加工完成，完成时间也不同，每台CNC只能完成其中的一道工序。
（2）RGV：RGV带有智能控制功能，能够接收和发送指令信号。根据指令能在直线轨道上移动和停止等待，可连续移动1个单位（两台相邻CNC间的距离）、2个单位（三台相邻CNC间的距离）和3个单位（四台相邻CNC间的距离）。RGV同一时间只能执行移动、停止等待、上下料和清洗作业中的一项。
（3）上料传送带：上料传送带由4段组成，在奇数编号CNC1#、3#、5#、7#前各有1段。由系统传感器控制，只能向一个方向传动，既能连动，也能独立运动。
（4）下料传送带：下料传送带由4段组成，在偶数编号CNC2#、4#、6#、8#前各有1段。由传感器控制，只能向同一个方向传动，既能连动，也能独立运动。

整个作业流程如下：
（1）智能加工系统通电启动后，RGV在CNC1#和CNC2#正中间的初始位置，所有CNC都处于空闲状态。
（2）在工作正常情况下，如果某CNC处于空闲状态，则向RGV发出上料需求信号；否则，CNC处于加工作业状态，在加工作业完成即刻向RGV发出需求信号。
（3）RGV在收到某CNC的需求信号后，它会自行确定该CNC的上下料作业次序，并依次按顺序为其上下料作业。根据需求指令，RGV运行至需要作业的某CNC处，同时上料传送带将生料送到该CNC正前方，供RGV上料作业。
RGV为偶数编号CNC一次上下料所需时间要大于为奇数编号CNC一次上下料所需时间。
（4）在RGV为某CNC完成一次上下料作业后，就会转动机械臂，将一只机械手上的熟料移动到清洗槽上方，进行清洗作业（只清洗加工完成的熟料）。
具体过程：首先用另一只机械手抓取出清洗槽中的成料、转动手爪、放入熟料到清洗槽中，然后转动机械臂，将成料放到下料传送带上送出系统。这个作业过程所需要的时间称为RGV清洗作业时间，并且在这个过程中RGV不能移动。
熟料在清洗槽中的实际清洗时间是很短的，远小于机械手将成料放到下料传送带上的时间。
（5）RGV在完成一项作业任务后，立即判别执行下一个作业指令。此时，如果没有接到其他的作业指令，则RGV就在原地等待直到下一个作业指令。
某CNC完成一个物料的加工作业任务后，即刻向RGV发出需求信号。如果RGV没能即刻到达为其上下料，该CNC就会出现等待。
（6）系统周而复始地重复（3）至（5），直到系统停止作业，RGV回到初始位置。

而我们的任务是建立数学模型和算法，来解决以下三种情况的问题：
（1）一道工序的物料加工作业情况，每台CNC安装同样的刀具，物料可以在任一台CNC上加工完成；
（2）两道工序的物料加工作业情况，每个物料的第一和第二道工序分别由两台不同的CNC依次加工完成；
（3）CNC在加工过程中可能发生故障（据统计：故障的发生概率约为1\%）的情况，每次故障排除（人工处理，未完成的物料报废）时间介于10~20分钟之间，故障排除后即刻加入作业序列。要求分别考虑一道工序和两道工序的物料加工作业情况。

对于一般的问题，我们需要建立模型提出算法，然后代入提供的三组数据，给出真实的调度策略以及系统的工作效率。


\subsection{问题的分析}

2.1 第一种情况的分析

为了能够加工完更多的产品，那么我们的想法就是让所有CNC的总等待时间尽量小。为了达到这一目的，我们会对8个CNC最早可以开始工作的时间进行排序，让RGV前往最早可以开始工作的CNC，这样不断循环直到时间结束。我们利用这样的一个贪心的策略来编写算法。我们实现了另外一个版本，是利用三层的深度优先搜索来决策下一步RGV需要去哪里。

2.2 第二种情况的分析

同样为了加工完成更多的产品，我们的想法也是先找一个最快可以开始工作的地方，分CNC加工的是第几道工序区别来运行不同的后续逻辑。同样也是利用一个贪心的策略来进行决策，运行程序，检验算法的有效性。

2.3 第三种情况的分析

第三种情况比前两种情况多了一个事件：机器会有1\%的概率发生故障。我们在前两种情况的算法基础上增加了一个随机数变量，使得运行中的机器有1\%的概率发生错误，同时产生另外一个随机数，表示机器修好的时间。而在决策过程中，我们会自动忽略所有故障中的机器。其余的决策过程和前两种情况类似。对于这样一个随机的过程，我们会运行20次取平均值，来求得一个接近期望的数值，表示我们算法的结果。


\section{模型的假设}

\begin{itemize}
\item 对于第一问和第二问，所有的时间可预测，决策可以使用未来的信息进行推断
\item 在第三问中机器的损坏是随机并且不可预测的，所以决策系统只知道此机器损坏的消息，同时不知道什么时候能够修好
\item 对于系统的作业效率，我们的理解是CNC在工作的时间除以CNC总共可以工作的时间
\end{itemize}

\section{符号说明}
\begin{center}
\begin{tabular}{cc}
 \hline
 \makebox[0.3\textwidth][c]{符号}	&  \makebox[0.4\textwidth][c]{意义} \\ \hline
 D	    & 木条宽度（cm） \\ \hline
 L	    & 木板长度（cm）  \\ \hline
 W	    & 木板宽度（cm）  \\ \hline
 N	    & 第n根木条  \\ \hline
 T	    & 木条根数  \\ \hline
\end{tabular}
\end{center}

\section{算法详解}

\subsection{情况一算法}

如前述，我们先自己实现了一个智能加工系统的模拟器(simulator.py)，可以模拟进行上下料、清洗、RGV移动等各种操作。随后我们先实现了一个贪心算法(choose1.py)。算法的主要思想是我们对8个CNC最早可以开始工作的时间进行排序。对于每个CNC，它最早可以开始工作的时间指的是RGV移动到它之后的时间与他结束自身工作的时间中的较大值，也就是代码中的max(walk_finish,s.Cnc(i).finish_time())。我们取8个CNC中最早可以开始工作的一个，开始工作。如此循环一直到时间结束。我们运行代码并获得了3组参数下该系统的实际调度策略以及系统的作业效率，调度策略在支撑材料中，而作业效率如下表所示。


经过对数据的分析可知：{\color{red}{还有啥}}

同样我们也实现了三层深度优先搜索的算法(choose1bru.py)。这个算法的想法是我们穷举RGV的之后三步走动与上下料，容易知道我们的搜索空间是一个深度为3的八叉树，我们选择时间最短的一个分支，向下走一步，然后继续进行深搜。通过对三组实际数据进行实验，我们发现最后的结果与我们贪心策略的结果是一致的，于是实验结果我们在此省略。

%问题流程图：
%\begin{figure}[!h]
%\centering
%\caption{问题三流程图}
%\end{figure}

\subsection{情况二算法}

对于第二种情况，我们同样采用了一个类似的贪心算法(choose2.py)。我们穷举加工第一道工序的CNC和加工第二道工序的CNC的排布方法，对每种排布方法，我们采用如下的贪心策略来进行决策：我们同样是对每个CNC最快可以开始工作的时间进行排序，然后我们选取一个最快可以开始工作的CNC（空闲状态的加工第二道工序的CNC除外），让RGV前往该处。如果这是处理第一道工序的CNC，在上料后RGV 查看一下是否获取了一个半成品，如果是，那么此时RGV就要前往最快可以开始工作的加工第二道工序的CNC，让其加工该半成品，此时如果拿到成品则进行清洗工作；如果RGV 并没有获取半成品，那么这一次循环结束，重新寻找下一个最快可以开始工作的CNC。如果一开始选取的是加工第二道工序的CNC，那么RGV就会直接下料，并进行清洗，这一次循环结束。

我们的主要想法就是让RGV前往可以尽快开始工作的地方，需要注意之处就是在于当RGV拿到半成品之后，由于RGV的手的数量有限，只能去前往加工第二道工序的CNC，而不是在全局搜索一个可以最快开始工作的地方。

经过对三组实际数据的运行，我们得到了如下的作业效率：


经过对数据的分析可知{\color{red}{还有啥}}

\subsection{情况三算法}

对于可能出现故障的机器，我们只需要对我们的算法略做修改即可。对于任意一台CNC，当元件被送入机器后，机器都有1\%的概率出现故障。在机器的修复过程中，我们的算法认为该台机器并不存在，而在故障修复后，该机器会立刻加入我们的考察队列中。我们以此来模拟出现故障的机器。而由于一次过程中存在随机性，我们会对每种情况都运行20次取平均值。在只有一道工序的时候，我们认为这个平均值就是我们算法求得的加工产品数量。在有两道工序的时候，我们穷举加工第一道工序的CNC和加工第二道工序的CNC的排布方法，对每种方法都运行20次求得平均加工数量，然后我们采用平均值最高的一种CNC排布方案当作我们选择的方案。

通过在三组实际数据上进行试验，我们得到了加工的调度策略（见支撑材料）以及作业效率（如下表）：


经过对数据的分析可知{\color{red}{还有啥}}

\section{模型评价与总结}

本文利用了贪心策略和深度优先搜索策略，对于原问题建立起的模型给出了较好的结果。我们的目的就是让RGV的空闲时间尽量少，所以我们希望RGV总是能够前往较快能开始工作的地方。

\subsection{模型优点}

1、实现了一个完全的智能加工系统模拟器(simulator.py)，该框架的存在使得我们的程序编写十分方便，可以应用各种算法。

2、使用了贪心以及深度优先算法对其中一个问题比较，得到了一定的结论。

\subsection{模型缺点}

1、对于两道工序的情况，穷举排布情况耗时长。

2、机器的使用效率不够高，希望可以利用启发式搜索来增加效率。


\section{绘制普通三线表格}
表格应具有三线表格式，因此常用 booktabs宏包，其标准格式如表~\ref{tab001}~所示。
\begin{table}[!htbp]
\caption{标准三线表格}\label{tab001} \centering
\begin{tabular}{ccccc}
\toprule[1.5pt]
$D$(in) & $P_u$(lbs) & $u_u$(in) & $\beta$ & $G_f$(psi.in)\\
\midrule[1pt]
 5 & 269.8 & 0.000674 & 1.79 & 0.04089\\
10 & 421.0 & 0.001035 & 3.59 & 0.04089\\
20 & 640.2 & 0.001565 & 7.18 & 0.04089\\
\bottomrule[1.5pt]
\end{tabular}
\end{table}

其绘制表格的代码及其说明如下。
\begin{tcode}
\begin{table}[!htbp]
\caption[标签名]{中文标题}
\begin{tabular}{cc...c}
\toprule[1.5pt]
表头第1个格   & 表头第2个格   & ... & 表头第n个格  \\
\midrule[1pt]
表中数据(1,1) & 表中数据(1,2) & ... & 表中数据(1,n)\\
表中数据(2,1) & 表中数据(2,2) & ... & 表中数据(2,n)\\
...................................................\\
表中数据(m,1) & 表中数据(m,2) & ... & 表中数据(m,n)\\
\bottomrule[1.5pt]
\end{tabular}
\end{table}
\end{tcode}

\bigskip
table环境是一个将表格嵌入文本的浮动环境。
tabular环境的必选参数由每列对应一个格式字符所组成：c表示居中，l表示左对齐，r表示右对齐，其总
个数应与表的列数相同。此外，\verb|@{文本}|可以出现在任意两个上述的列格式之间，其中的文本将被插入每一行
的同一位置。表格的各行以\verb|\\|分隔，同一行的各列则以\&分隔。
\verb|\toprule|、\verb|\midrule|和\verb|\bottomrule|三个命令是由booktabs宏包提供的，其
中\verb|\toprule|和\verb|\bottomrule|分别用来绘制表格的第一条（表格最顶部）和第三条（表格最底部）水平线，
\verb|\midrule|用来绘制第二条（表头之下）水平线，且第一条和第三条水平线的线宽为1.5pt，第二条水平线的线宽为1pt。
引用方法：“如表~\verb|\ref{标签名}|~所示”。


%参考文献
\begin{thebibliography}{9}%宽度9
 \bibitem{bib:one} ....
 \bibitem{bib:two} ....
\end{thebibliography}

\newpage
%附录
\begin{appendices}
\section{RGV行为模拟器--Python源代码}
%\begin{lstlisting}[language=python]
%\input{../simulator.py}
%\end{lstlisting}
\lstinputlisting[language=python]{../simulator.py}
\section{规划解决程序--lingo源代码}
\begin{lstlisting}[language=c]
kk=2;
[mdd,ndd]=size(dd);
while ~isempty(V)
    [tmpd,j]=min(W(i,V));tmpj=V(j);
for k=2:ndd
    [tmp1,jj]=min(dd(1,k)+W(dd(2,k),V));
    tmp2=V(jj);tt(k-1,:)=[tmp1,tmp2,jj];
end
    tmp=[tmpd,tmpj,j;tt];[tmp3,tmp4]=min(tmp(:,1));
if tmp3==tmpd, ss(1:2,kk)=[i;tmp(tmp4,2)];
else,tmp5=find(ss(:,tmp4)~=0);tmp6=length(tmp5);
if dd(2,tmp4)==ss(tmp6,tmp4)
    ss(1:tmp6+1,kk)=[ss(tmp5,tmp4);tmp(tmp4,2)];
else, ss(1:3,kk)=[i;dd(2,tmp4);tmp(tmp4,2)];
end;
end
    dd=[dd,[tmp3;tmp(tmp4,2)]];V(tmp(tmp4,3))=[];
    [mdd,ndd]=size(dd);
    kk=kk+1;
end;
S=ss;
D=dd(1,:);
 \end{lstlisting}
\end{appendices}

\end{document}
